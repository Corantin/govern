{
  "language": "Solidity",
  "sources": {
    "contracts/erc1271/ERC1271.sol": {
      "content": "/*\r\n * SPDX-License-Identifier:    MIT\r\n */\r\n\r\npragma solidity ^0.6.8;\r\n\r\n/**\r\n* @title ERC1271 interface\r\n* @dev see https://eips.ethereum.org/EIPS/eip-1271\r\n*/\r\nabstract contract ERC1271 {\r\n    // bytes4(keccak256(\"isValidSignature(bytes32,bytes)\")\r\n    bytes4 constant internal MAGICVALUE = 0x1626ba7e;\r\n\r\n    /**\r\n    * @dev Should return whether the signature provided is valid for the provided data\r\n    * @param _hash Keccak256 hash of arbitrary length data signed on the behalf of address(this)\r\n    * @param _signature Signature byte array associated with _data\r\n    *\r\n    * MUST return the bytes4 magic value 0x1626ba7e when function passes.\r\n    * MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5)\r\n    * MUST allow external calls\r\n    */\r\n    function isValidSignature(bytes32 _hash, bytes memory _signature) virtual public view returns (bytes4 magicValue);\r\n}\r\n"
    },
    "contracts/Govern.sol": {
      "content": "/*\r\n * SPDX-License-Identifier:    GPL-3.0\r\n */\r\n\r\npragma solidity 0.6.8;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"erc3k/contracts/IERC3000Executor.sol\";\r\nimport \"erc3k/contracts/IERC3000.sol\";\r\n\r\nimport \"@aragon/govern-contract-utils/contracts/acl/ACL.sol\";\r\nimport \"@aragon/govern-contract-utils/contracts/adaptive-erc165/AdaptiveERC165.sol\";\r\nimport \"@aragon/govern-contract-utils/contracts/bitmaps/BitmapLib.sol\";\r\nimport \"@aragon/govern-contract-utils/contracts/address-utils/AddressUtils.sol\";\r\nimport \"@aragon/govern-contract-utils/contracts/erc20/ERC20.sol\";\r\nimport \"@aragon/govern-contract-utils/contracts/erc20/SafeERC20.sol\";\r\n\r\nimport \"./erc1271/ERC1271.sol\";\r\n\r\ncontract Govern is IERC3000Executor, AdaptiveERC165, ERC1271, ACL {\r\n    using BitmapLib for bytes32;\r\n    using AddressUtils for address;\r\n    using SafeERC20 for ERC20;\r\n\r\n    string private constant ERROR_DEPOSIT_AMOUNT_ZERO = \"GOVERN_DEPOSIT_AMOUNT_ZERO\";\r\n    string private constant ERROR_ETH_DEPOSIT_AMOUNT_MISMATCH = \"GOVERN_ETH_DEPOSIT_AMOUNT_MISMATCH\";\r\n    string private constant ERROR_TOKEN_NOT_CONTRACT = \"GOVERN_TOKEN_NOT_CONTRACT\";\r\n    string private constant ERROR_TOKEN_DEPOSIT_FAILED = \"GOVERN_TOKEN_DEPOSIT_FAILED\";\r\n    string private constant ERROR_TOO_MANY_ACTIONS = \"GOVERN_TOO_MANY_ACTIONS\";\r\n    string private constant ERROR_ACTION_CALL_FAILED = \"GOVERN_ACTION_CALL_FAILED\";\r\n    string private constant ERROR_TOKEN_WITHDRAW_FAILED = \"GOVERN_TOKEN_WITHDRAW_FAILED\";\r\n    string private constant ERROR_ETH_WITHDRAW_FAILED = \"GOVERN_ETH_WITHDRAW_FAILED\";\r\n\r\n    bytes4 internal constant EXEC_ROLE = this.exec.selector;\r\n    bytes4 internal constant WITHDRAW_ROLE = this.withdraw.selector;\r\n\r\n    bytes4 internal constant REGISTER_STANDARD_ROLE = this.registerStandardAndCallback.selector;\r\n    bytes4 internal constant SET_SIGNATURE_VALIDATOR_ROLE = this.setSignatureValidator.selector;\r\n    uint256 internal constant MAX_ACTIONS = 256;\r\n\r\n    ERC1271 signatureValidator;\r\n\r\n    // ETHDeposited and Deposited are both needed. ETHDeposited makes sure that whoever sends funds\r\n    // with `send/transfer`, receive function can still be executed without reverting due to gas cost\r\n    // increases in EIP-2929. To still use `send/transfer`, access list is needed that has the address\r\n    // of the contract(base contract) that is behind the proxy.\r\n    event ETHDeposited(address sender, uint256 amount);\r\n\r\n    event Deposited(address indexed sender, address indexed token, uint256 amount, string _reference);\r\n    event Withdrawn(address indexed token, address indexed to, address from, uint256 amount, string _reference);\r\n\r\n    constructor(address _initialExecutor) ACL(address(this)) public {\r\n        initialize(_initialExecutor);\r\n    }\r\n\r\n    function initialize(address _initialExecutor) public initACL(address(this)) onlyInit(\"govern\") {\r\n        _grant(EXEC_ROLE, address(_initialExecutor));\r\n        _grant(WITHDRAW_ROLE, address(this));\r\n\r\n        // freeze the withdraw so that only GovernExecutor can call\r\n        _freeze(WITHDRAW_ROLE);\r\n\r\n        _grant(REGISTER_STANDARD_ROLE, address(this));\r\n        _grant(SET_SIGNATURE_VALIDATOR_ROLE, address(this));\r\n\r\n        _registerStandard(ERC3000_EXEC_INTERFACE_ID);\r\n        _registerStandard(type(ERC1271).interfaceId);\r\n    }\r\n\r\n    receive () external payable {\r\n        emit ETHDeposited(msg.sender, msg.value);\r\n    }\r\n\r\n    fallback () external {\r\n        _handleCallback(msg.sig, msg.data); // WARN: does a low-level return, any code below would be unreacheable\r\n    }\r\n\r\n    function deposit(address _token, uint256 _amount, string calldata _reference) external payable {\r\n        require(_amount > 0, ERROR_DEPOSIT_AMOUNT_ZERO);\r\n\r\n        if (_token == address(0)) {\r\n            require(msg.value == _amount, ERROR_ETH_DEPOSIT_AMOUNT_MISMATCH);\r\n        } else {\r\n            require(_token.isContract(), ERROR_TOKEN_NOT_CONTRACT);\r\n            require(ERC20(_token).safeTransferFrom(msg.sender, address(this), _amount), ERROR_TOKEN_DEPOSIT_FAILED);\r\n        }\r\n        emit Deposited(msg.sender, _token, _amount, _reference);\r\n    }\r\n\r\n    function withdraw(address _token, address _from, address _to, uint256 _amount, string memory _reference) public auth(WITHDRAW_ROLE) {\r\n        if (_token == address(0)) {\r\n            (bool ok, ) = _to.call{value: _amount}(\"\");\r\n            require(ok, ERROR_ETH_WITHDRAW_FAILED);\r\n        } else {\r\n            require(ERC20(_token).safeTransfer(_to, _amount), ERROR_TOKEN_WITHDRAW_FAILED);\r\n        }\r\n        emit Withdrawn(_token, _to, _from, _amount, _reference);\r\n    }\r\n\r\n    function exec(ERC3000Data.Action[] memory actions, bytes32 allowFailuresMap, bytes32 memo) override public auth(EXEC_ROLE) returns (bytes32, bytes[] memory) {\r\n        require(actions.length <= MAX_ACTIONS, ERROR_TOO_MANY_ACTIONS); // need to limit since we use 256-bit bitmaps\r\n\r\n        bytes[] memory execResults = new bytes[](actions.length);\r\n        bytes32 failureMap = BitmapLib.empty; // start with an empty bitmap\r\n\r\n        for (uint256 i = 0; i < actions.length; i++) {\r\n            // TODO: optimize with assembly\r\n            (bool ok, bytes memory ret) = actions[i].to.call{value: actions[i].value}(actions[i].data);\r\n            require(ok || allowFailuresMap.get(uint8(i)), ERROR_ACTION_CALL_FAILED);\r\n            // if a call fails, flip that bit to signal failure\r\n            failureMap = ok ? failureMap : failureMap.flip(uint8(i));\r\n            execResults[i] = ret;\r\n        }\r\n\r\n        emit Executed(msg.sender, actions, memo, failureMap, execResults);\r\n\r\n        return (failureMap, execResults);\r\n    }\r\n\r\n    function registerStandardAndCallback(bytes4 _interfaceId, bytes4 _callbackSig, bytes4 _magicNumber) external auth(REGISTER_STANDARD_ROLE) {\r\n        _registerStandardAndCallback(_interfaceId, _callbackSig, _magicNumber);\r\n    }\r\n\r\n    function setSignatureValidator(ERC1271 _signatureValidator) external auth(SET_SIGNATURE_VALIDATOR_ROLE) {\r\n        signatureValidator = _signatureValidator;\r\n    }\r\n\r\n    function isValidSignature(bytes32 _hash, bytes memory _signature) override public view returns (bytes4) {\r\n        if (address(signatureValidator) == address(0)) return bytes4(0); // invalid magic number\r\n        return signatureValidator.isValidSignature(_hash, _signature); // forward call to set validation contract\r\n    }\r\n}\r\n"
    },
    "erc3k/contracts/IERC3000Executor.sol": {
      "content": "/*\r\n * SPDX-License-Identifier:    MIT\r\n */\r\n\r\npragma solidity ^0.6.8;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"./ERC3000Data.sol\";\r\n\r\nabstract contract IERC3000Executor {\r\n    bytes4 internal constant ERC3000_EXEC_INTERFACE_ID = this.exec.selector;\r\n\r\n    /**\r\n     * @notice Executes all given actions\r\n     * @param actions A array of ERC3000Data.Action for later executing those\r\n     * @param allowFailuresMap A map with the allowed failures\r\n     * @param memo The hash of the ERC3000Data.Container\r\n     * @return failureMap\r\n     * @return execResults\r\n     */\r\n    function exec(ERC3000Data.Action[] memory actions, bytes32 allowFailuresMap, bytes32 memo) virtual public returns (bytes32 failureMap, bytes[] memory execResults);\r\n    event Executed(address indexed actor, ERC3000Data.Action[] actions, bytes32 memo, bytes32 failureMap, bytes[] execResults);\r\n}\r\n"
    },
    "erc3k/contracts/IERC3000.sol": {
      "content": "/*\r\n * SPDX-License-Identifier:    MIT\r\n */\r\n\r\npragma solidity ^0.6.8;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"./ERC3000Data.sol\";\r\n\r\nabstract contract IERC3000 {\r\n    /**\r\n     * @notice Schedules an action for execution, allowing for challenges and vetos on a defined time window\r\n     * @param container A Container struct holding both the payload being scheduled for execution and\r\n     * the current configuration of the system\r\n     * @return containerHash\r\n     */\r\n    function schedule(ERC3000Data.Container memory container) virtual public returns (bytes32 containerHash);\r\n    event Scheduled(bytes32 indexed containerHash, ERC3000Data.Payload payload);\r\n\r\n    /**\r\n     * @notice Executes an action after its execution delay has passed and its state hasn't been altered by a challenge or veto\r\n     * @param container A ERC3000Data.Container struct holding both the payload being scheduled for execution and\r\n     * the current configuration of the system\r\n     * MUST be an ERC3000Executor call: payload.executor.exec(payload.actions)\r\n     * @return failureMap\r\n     * @return execResults\r\n     */\r\n    function execute(ERC3000Data.Container memory container) virtual public returns (bytes32 failureMap, bytes[] memory execResults);\r\n    event Executed(bytes32 indexed containerHash, address indexed actor);\r\n\r\n    /**\r\n     * @notice Challenge a container in case its scheduling is illegal as per Config.rules. Pulls collateral and dispute fees from sender into contract\r\n     * @param container A ERC3000Data.Container struct holding both the payload being scheduled for execution and\r\n     * the current configuration of the system\r\n     * @param reason Hint for case reviewers as to why the scheduled container is illegal\r\n     * @return resolverId\r\n     */\r\n    function challenge(ERC3000Data.Container memory container, bytes memory reason) virtual public returns (uint256 resolverId);\r\n    event Challenged(bytes32 indexed containerHash, address indexed actor, bytes reason, uint256 resolverId, ERC3000Data.Collateral collateral);\r\n\r\n    /**\r\n     * @notice Apply arbitrator's ruling over a challenge once it has come to a final ruling\r\n     * @param container A ERC3000Data.Container struct holding both the payload being scheduled for execution and\r\n     * the current configuration of the system\r\n     * @param resolverId disputeId in the arbitrator in which the dispute over the container was created\r\n     * @return failureMap\r\n     * @return execResults\r\n     */\r\n    function resolve(ERC3000Data.Container memory container, uint256 resolverId) virtual public returns (bytes32 failureMap, bytes[] memory execResults);\r\n    event Resolved(bytes32 indexed containerHash, address indexed actor, bool approved);\r\n\r\n    /**\r\n     * @notice Apply arbitrator's ruling over a challenge once it has come to a final ruling\r\n     * @param container A ERC3000Data.Container struct holding both the payload being scheduled for execution and\r\n     * the current configuration of the system\r\n     * @param reason Justification for the veto\r\n     */\r\n    function veto(ERC3000Data.Container memory container, bytes memory reason) virtual public;\r\n    event Vetoed(bytes32 indexed containerHash, address indexed actor, bytes reason);\r\n\r\n    /**\r\n     * @notice Apply a new configuration for all *new* containers to be scheduled\r\n     * @param config A ERC3000Data.Config struct holding all the new params that will control the system\r\n     * @return configHash\r\n     */\r\n    function configure(ERC3000Data.Config memory config) virtual public returns (bytes32 configHash);\r\n    event Configured(bytes32 indexed configHash, address indexed actor, ERC3000Data.Config config);\r\n}\r\n"
    },
    "@aragon/govern-contract-utils/contracts/acl/ACL.sol": {
      "content": "/*\r\n * SPDX-License-Identifier:    MIT\r\n */\r\n\r\npragma solidity ^0.6.8;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"../initializable/Initializable.sol\";\r\n\r\nimport \"./IACLOracle.sol\";\r\n\r\nlibrary ACLData {\r\n    enum BulkOp { Grant, Revoke, Freeze }\r\n\r\n    struct BulkItem {\r\n        BulkOp op;\r\n        bytes4 role;\r\n        address who;\r\n    }\r\n}\r\n\r\ncontract ACL is Initializable {\r\n    bytes4 public constant ROOT_ROLE =\r\n        this.grant.selector\r\n        ^ this.revoke.selector\r\n        ^ this.freeze.selector\r\n        ^ this.bulk.selector\r\n    ;\r\n\r\n    // \"Who\" constants\r\n    address internal constant ANY_ADDR = address(-1);\r\n\r\n    // \"Access\" flags\r\n    address internal constant UNSET_ROLE = address(0);\r\n    address internal constant FREEZE_FLAG = address(1); // Also used as \"who\"\r\n    address internal constant ALLOW_FLAG = address(2);\r\n\r\n    // Role -> Who -> Access flag (unset or allow) or ACLOracle (any other address denominates auth via ACLOracle)\r\n    mapping (bytes4 => mapping (address => address)) public roles;\r\n\r\n    event Granted(bytes4 indexed role, address indexed actor, address indexed who, IACLOracle oracle);\r\n    event Revoked(bytes4 indexed role, address indexed actor, address indexed who);\r\n    event Frozen(bytes4 indexed role, address indexed actor);\r\n\r\n    modifier auth(bytes4 _role) {\r\n        require(willPerform(_role, msg.sender, msg.data), \"acl: auth\");\r\n        _;\r\n    }\r\n\r\n    modifier initACL(address _initialRoot) {\r\n        // ACL might have been already initialized by constructors\r\n        if (initBlocks[\"acl\"] == 0) {\r\n            _initializeACL(_initialRoot);\r\n        } else {\r\n            require(roles[ROOT_ROLE][_initialRoot] == ALLOW_FLAG, \"acl: initial root misaligned\");\r\n        }\r\n        _;\r\n    }\r\n\r\n    constructor(address _initialRoot) public initACL(_initialRoot) { }\r\n\r\n    function grant(bytes4 _role, address _who) external auth(ROOT_ROLE) {\r\n        _grant(_role, _who);\r\n    }\r\n\r\n    function grantWithOracle(bytes4 _role, address _who, IACLOracle _oracle) external auth(ROOT_ROLE) {\r\n        _grantWithOracle(_role, _who, _oracle);\r\n    }\r\n\r\n    function revoke(bytes4 _role, address _who) external auth(ROOT_ROLE) {\r\n        _revoke(_role, _who);\r\n    }\r\n\r\n    function freeze(bytes4 _role) external auth(ROOT_ROLE) {\r\n        _freeze(_role);\r\n    }\r\n\r\n    function bulk(ACLData.BulkItem[] calldata items) external auth(ROOT_ROLE) {\r\n        for (uint256 i = 0; i < items.length; i++) {\r\n            ACLData.BulkItem memory item = items[i];\r\n\r\n            if (item.op == ACLData.BulkOp.Grant) _grant(item.role, item.who);\r\n            else if (item.op == ACLData.BulkOp.Revoke) _revoke(item.role, item.who);\r\n            else if (item.op == ACLData.BulkOp.Freeze) _freeze(item.role);\r\n        }\r\n    }\r\n\r\n    function willPerform(bytes4 _role, address _who, bytes memory _data) internal returns (bool) {\r\n        // First check if the given who is auth'd, then if any address is auth'd\r\n        return _checkRole(_role, _who, _data) || _checkRole(_role, ANY_ADDR, _data);\r\n    }\r\n\r\n    function isFrozen(bytes4 _role) public view returns (bool) {\r\n        return roles[_role][FREEZE_FLAG] == FREEZE_FLAG;\r\n    }\r\n\r\n    function _initializeACL(address _initialRoot) internal onlyInit(\"acl\") {\r\n        _grant(ROOT_ROLE, _initialRoot);\r\n    }\r\n\r\n    function _grant(bytes4 _role, address _who) internal {\r\n        _grantWithOracle(_role, _who, IACLOracle(ALLOW_FLAG));\r\n    }\r\n\r\n    function _grantWithOracle(bytes4 _role, address _who, IACLOracle _oracle) internal {\r\n        require(!isFrozen(_role), \"acl: frozen\");\r\n        require(_who != FREEZE_FLAG, \"acl: bad freeze\");\r\n\r\n        roles[_role][_who] = address(_oracle);\r\n        emit Granted(_role, msg.sender, _who, _oracle);\r\n    }\r\n\r\n    function _revoke(bytes4 _role, address _who) internal {\r\n        require(!isFrozen(_role), \"acl: frozen\");\r\n\r\n        roles[_role][_who] = UNSET_ROLE;\r\n        emit Revoked(_role, msg.sender, _who);\r\n    }\r\n\r\n    function _freeze(bytes4 _role) internal {\r\n        require(!isFrozen(_role), \"acl: frozen\");\r\n\r\n        roles[_role][FREEZE_FLAG] = FREEZE_FLAG;\r\n        emit Frozen(_role, msg.sender);\r\n    }\r\n\r\n    function _checkRole(bytes4 _role, address _who, bytes memory _data) internal returns (bool) {\r\n        address accessFlagOrAclOracle = roles[_role][_who];\r\n        if (accessFlagOrAclOracle != UNSET_ROLE) {\r\n            if (accessFlagOrAclOracle == ALLOW_FLAG) return true;\r\n\r\n            // Since it's not a flag, assume it's an ACLOracle and try-catch to skip failures\r\n            try IACLOracle(accessFlagOrAclOracle).willPerform(_role, _who, _data) returns (bool allowed) {\r\n                if (allowed) return true;\r\n            } catch { }\r\n        }\r\n\r\n        return false;\r\n    }\r\n}\r\n"
    },
    "@aragon/govern-contract-utils/contracts/adaptive-erc165/AdaptiveERC165.sol": {
      "content": "/*\r\n * SPDX-License-Identifier:    MIT\r\n */\r\n\r\npragma solidity ^0.6.8;\r\n\r\nimport \"../erc165/ERC165.sol\";\r\n\r\ncontract AdaptiveERC165 is ERC165 {\r\n    // ERC165 interface ID -> whether it is supported\r\n    mapping (bytes4 => bool) internal standardSupported;\r\n    // Callback function signature -> magic number to return\r\n    mapping (bytes4 => bytes32) internal callbackMagicNumbers;\r\n\r\n    bytes32 internal constant UNREGISTERED_CALLBACK = bytes32(0);\r\n\r\n    event RegisteredStandard(bytes4 interfaceId);\r\n    event RegisteredCallback(bytes4 sig, bytes4 magicNumber);\r\n    event ReceivedCallback(bytes4 indexed sig, bytes data);\r\n\r\n    function supportsInterface(bytes4 _interfaceId) override virtual public view returns (bool) {\r\n        return standardSupported[_interfaceId] || super.supportsInterface(_interfaceId);\r\n    }\r\n\r\n    function _handleCallback(bytes4 _sig, bytes memory _data) internal {\r\n        bytes32 magicNumber = callbackMagicNumbers[_sig];\r\n        require(magicNumber != UNREGISTERED_CALLBACK, \"adap-erc165: unknown callback\");\r\n\r\n        emit ReceivedCallback(_sig, _data);\r\n\r\n        // low-level return magic number\r\n        assembly {\r\n            mstore(0x00, magicNumber)\r\n            return(0x00, 0x20)\r\n        }\r\n    }\r\n\r\n    function _registerStandardAndCallback(bytes4 _interfaceId, bytes4 _callbackSig, bytes4 _magicNumber) internal {\r\n        _registerStandard(_interfaceId);\r\n        _registerCallback(_callbackSig, _magicNumber);\r\n    }\r\n\r\n    function _registerStandard(bytes4 _interfaceId) internal {\r\n        standardSupported[_interfaceId] = true;\r\n        emit RegisteredStandard(_interfaceId);\r\n    }\r\n\r\n    function _registerCallback(bytes4 _callbackSig, bytes4 _magicNumber) internal {\r\n        callbackMagicNumbers[_callbackSig] = _magicNumber;\r\n        emit RegisteredCallback(_callbackSig, _magicNumber);\r\n    }\r\n}\r\n"
    },
    "@aragon/govern-contract-utils/contracts/bitmaps/BitmapLib.sol": {
      "content": "/*\r\n * SPDX-License-Identifier:    MIT\r\n */\r\n\r\npragma solidity ^0.6.8;\r\n\r\nlibrary BitmapLib {\r\n    bytes32 constant internal empty = bytes32(0);\r\n\r\n    function flip(bytes32 map, uint8 index) internal pure returns (bytes32) {\r\n        return bytes32(uint256(map) ^ uint256(1) << index);\r\n    }\r\n\r\n    function get(bytes32 map, uint8 index) internal pure returns (bool) {\r\n        return (uint256(map) >> index & 1) == 1;\r\n    }\r\n}\r\n"
    },
    "@aragon/govern-contract-utils/contracts/address-utils/AddressUtils.sol": {
      "content": "/*\r\n * SPDX-License-Identifier:    MIT\r\n */\r\n\r\npragma solidity ^0.6.8;\r\n\r\nlibrary AddressUtils {\r\n    \r\n    function toPayable(address addr) internal pure returns (address payable) {\r\n        return address(bytes20(addr));\r\n    }\r\n\r\n    /**\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     */\r\n    function isContract(address addr) internal view returns (bool result) {\r\n        assembly {\r\n            result := iszero(iszero(extcodesize(addr)))\r\n        }\r\n    }\r\n}\r\n"
    },
    "@aragon/govern-contract-utils/contracts/erc20/ERC20.sol": {
      "content": "/*\r\n * SPDX-License-Identifier:    MIT\r\n */\r\n\r\npragma solidity ^0.6.8;\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ninterface ERC20 {\r\n    // Optional fields \r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function decimals() external view returns (uint8);\r\n\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address _who) external view returns (uint256);\r\n\r\n    function allowance(address _owner, address _spender) external view returns (uint256);\r\n\r\n    function transfer(address _to, uint256 _value) external returns (bool);\r\n\r\n    function approve(address _spender, uint256 _value) external returns (bool);\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\r\n\r\n    event Transfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 value\r\n    );\r\n\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\n"
    },
    "@aragon/govern-contract-utils/contracts/erc20/SafeERC20.sol": {
      "content": "/*\r\n * SPDX-License-Identifier:    MIT\r\n */\r\n\r\n// From https://github.com/aragon/aragonOS/blob/next/contracts/common/SafeERC20.sol\r\n\r\n// Inspired by AdEx (https://github.com/AdExNetwork/adex-protocol-eth/blob/b9df617829661a7518ee10f4cb6c4108659dd6d5/contracts/libs/SafeERC20.sol)\r\n// and 0x (https://github.com/0xProject/0x-monorepo/blob/737d1dc54d72872e24abce5a1dbe1b66d35fa21a/contracts/protocol/contracts/protocol/AssetProxy/ERC20Proxy.sol#L143)\r\n\r\npragma solidity ^0.6.8;\r\n\r\nimport \"../address-utils/AddressUtils.sol\";\r\n\r\nimport \"./ERC20.sol\";\r\n\r\nlibrary SafeERC20 {\r\n    using AddressUtils for address;\r\n\r\n    function invokeAndCheckSuccess(address _addr, bytes memory _calldata)\r\n        private\r\n        returns (bool ret)\r\n    {\r\n        if (!_addr.isContract()) {\r\n            return false;\r\n        }\r\n\r\n        assembly {\r\n            let ptr := mload(0x40)    // free memory pointer\r\n\r\n            let success := call(\r\n                gas(),                // forward all\r\n                _addr,                // address\r\n                0,                    // no value\r\n                add(_calldata, 0x20), // calldata start\r\n                mload(_calldata),     // calldata length\r\n                ptr,                  // write output over free memory\r\n                0x20                  // uint256 return\r\n            )\r\n\r\n            if gt(success, 0) {\r\n                // Check number of bytes returned from last function call\r\n                switch returndatasize()\r\n\r\n                // No bytes returned: assume success\r\n                case 0 {\r\n                    ret := 1\r\n                }\r\n\r\n                // 32 bytes returned: check if non-zero\r\n                case 0x20 {\r\n                    // Only return success if returned data was true\r\n                    // Already have output in ptr\r\n                    ret := iszero(iszero(mload(ptr)))\r\n                }\r\n\r\n                // Not sure what was returned: don't mark as success\r\n                default { }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Same as a standards-compliant ERC20.transfer() that never reverts (returns false).\r\n    *      Note that this makes an external call to the token.\r\n    */\r\n    function safeTransfer(ERC20 _token, address _to, uint256 _amount) internal returns (bool) {\r\n        bytes memory transferCallData = abi.encodeWithSelector(\r\n            _token.transfer.selector,\r\n            _to,\r\n            _amount\r\n        );\r\n        return invokeAndCheckSuccess(address(_token), transferCallData);\r\n    }\r\n\r\n    /**\r\n    * @dev Same as a standards-compliant ERC20.transferFrom() that never reverts (returns false).\r\n    *      Note that this makes an external call to the token.\r\n    */\r\n    function safeTransferFrom(ERC20 _token, address _from, address _to, uint256 _amount) internal returns (bool) {\r\n        bytes memory transferFromCallData = abi.encodeWithSelector(\r\n            _token.transferFrom.selector,\r\n            _from,\r\n            _to,\r\n            _amount\r\n        );\r\n        return invokeAndCheckSuccess(address(_token), transferFromCallData);\r\n    }\r\n\r\n    /**\r\n    * @dev Same as a standards-compliant ERC20.approve() that never reverts (returns false).\r\n    *      Note that this makes an external call to the token.\r\n    */\r\n    function safeApprove(ERC20 _token, address _spender, uint256 _amount) internal returns (bool) {\r\n        bytes memory approveCallData = abi.encodeWithSelector(\r\n            _token.approve.selector,\r\n            _spender,\r\n            _amount\r\n        );\r\n        return invokeAndCheckSuccess(address(_token), approveCallData);\r\n    }\r\n}\r\n"
    },
    "erc3k/contracts/ERC3000Data.sol": {
      "content": "/*\r\n * SPDX-License-Identifier:    MIT\r\n */\r\n\r\npragma solidity ^0.6.8;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport './IERC3000Executor.sol';\r\n\r\nlibrary ERC3000Data {\r\n    // TODO: come up with a non-shitty name\r\n    struct Container {\r\n        Payload payload;\r\n        Config config;\r\n    }\r\n\r\n    // WARN: Always remember to change the 'hash' function if modifying the struct\r\n    struct Payload {\r\n        uint256 nonce;\r\n        uint256 executionTime;\r\n        address submitter;\r\n        IERC3000Executor executor;\r\n        Action[] actions;\r\n        bytes32 allowFailuresMap;\r\n        bytes proof;\r\n        address challenger;\r\n    }\r\n\r\n    struct Action {\r\n        address to;\r\n        uint256 value;\r\n        bytes data;\r\n    }\r\n\r\n    struct Config {\r\n        uint256 executionDelay; // how many seconds to wait before being able to call `execute`.\r\n        Collateral scheduleDeposit; // fees for scheduling\r\n        Collateral challengeDeposit; // fees for challenging\r\n        address resolver; // resolver that will rule the disputes\r\n        bytes rules; // rules of how DAO should be managed\r\n        uint256 maxCalldataSize; // max calldatasize for the schedule\r\n    }\r\n\r\n    struct Collateral {\r\n        address token;\r\n        uint256 amount;\r\n    }\r\n\r\n    function containerHash(bytes32 payloadHash, bytes32 configHash)\r\n        internal\r\n        view\r\n        returns (bytes32)\r\n    {\r\n        uint256 chainId;\r\n        assembly {\r\n            chainId := chainid()\r\n        }\r\n\r\n        return\r\n            keccak256(\r\n                abi.encodePacked(\r\n                    'erc3k-v1',\r\n                    address(this),\r\n                    chainId,\r\n                    payloadHash,\r\n                    configHash\r\n                )\r\n            );\r\n    }\r\n\r\n    function hash(Container memory container) internal view returns (bytes32) {\r\n        return containerHash(hash(container.payload), hash(container.config));\r\n    }\r\n\r\n    function hash(Payload memory payload) internal pure returns (bytes32) {\r\n        return\r\n            keccak256(\r\n                abi.encode(\r\n                    payload.nonce,\r\n                    payload.executionTime,\r\n                    payload.submitter,\r\n                    payload.executor,\r\n                    keccak256(abi.encode(payload.actions)),\r\n                    payload.allowFailuresMap,\r\n                    keccak256(payload.proof)\r\n                )\r\n            );\r\n    }\r\n\r\n    function hash(Config memory config) internal pure returns (bytes32) {\r\n        return keccak256(abi.encode(config));\r\n    }\r\n}\r\n"
    },
    "@aragon/govern-contract-utils/contracts/initializable/Initializable.sol": {
      "content": "/*\r\n * SPDX-License-Identifier:    MIT\r\n */\r\n\r\npragma solidity 0.6.8;\r\n\r\ncontract Initializable {\r\n    mapping (string => uint256) public initBlocks;\r\n\r\n    event Initialized(string indexed key);\r\n\r\n    modifier onlyInit(string memory key) {\r\n        require(initBlocks[key] == 0, \"initializable: already initialized\");\r\n        initBlocks[key] = block.number;\r\n        _;\r\n        emit Initialized(key);\r\n    }\r\n}\r\n"
    },
    "@aragon/govern-contract-utils/contracts/acl/IACLOracle.sol": {
      "content": "/*\r\n * SPDX-License-Identifier:    MIT\r\n */\r\n\r\npragma solidity ^0.6.8;\r\n\r\ninterface IACLOracle {\r\n    function willPerform(bytes4 role, address who, bytes calldata data) external returns (bool allowed);\r\n}\r\n"
    },
    "@aragon/govern-contract-utils/contracts/erc165/ERC165.sol": {
      "content": "/*\r\n * SPDX-License-Identifier:    MIT\r\n */\r\n\r\npragma solidity ^0.6.8;\r\n\r\nabstract contract ERC165 {\r\n    // Includes supportsInterface method:\r\n    bytes4 internal constant ERC165_INTERFACE_ID = bytes4(0x01ffc9a7);\r\n\r\n    /**\r\n    * @dev Query if a contract implements a certain interface\r\n    * @param _interfaceId The interface identifier being queried, as specified in ERC-165\r\n    * @return True if the contract implements the requested interface and if its not 0xffffffff, false otherwise\r\n    */\r\n    function supportsInterface(bytes4 _interfaceId) virtual public view returns (bool) {\r\n        return _interfaceId == ERC165_INTERFACE_ID;\r\n    }\r\n}\r\n"
    },
    "contracts/test/ArbitratorWrongSubjectMock.sol": {
      "content": "\r\n/*\r\n * SPDX-License-Identifier:    GPL-3.0\r\n */\r\n\r\npragma solidity ^0.6.8;\r\n\r\nimport \"./ArbitratorMock.sol\";\r\nimport \"@aragon/govern-contract-utils/contracts/erc20/SafeERC20.sol\";\r\n\r\ncontract ArbitratorWrongSubjectMock is ArbitratorMock {\r\n\r\n\r\n    constructor(ERC20 _token) ArbitratorMock(_token) public {\r\n\r\n    }\r\n\r\n    /**\r\n    * @dev Tell the winning outcome of the final ruling.\r\n    * @return subject address who made the dispute\r\n    * @return rulingExecuted final outcome\r\n    */\r\n    function rule(uint256 /*_disputeId*/) override view external returns(address, uint256){\r\n        return (address(0), 4);\r\n    }\r\n\r\n}"
    },
    "contracts/test/ArbitratorMock.sol": {
      "content": "/*\r\n * SPDX-License-Identifier:    MIT\r\n */\r\n\r\npragma solidity ^0.6.8;\r\n\r\nimport \"@aragon/govern-contract-utils/contracts/erc20/SafeERC20.sol\";\r\n\r\ncontract ArbitratorMock {\r\n    using SafeERC20 for ERC20;\r\n\r\n    ERC20 public token;\r\n\r\n    uint256 public possibleRulings;\r\n    bytes   public metadata;\r\n    uint256 public evidencePeriodClosed;\r\n    uint256 public rulingExecuted;\r\n    address public subject;\r\n    uint256 public winningOutcome;\r\n\r\n\r\n    constructor(ERC20 _token) public {\r\n        token = _token;\r\n    }\r\n\r\n    /**\r\n    * @dev Create a dispute over the Arbitrable sender with a number of possible rulings\r\n    * @param _possibleRulings Number of possible rulings allowed for the dispute\r\n    * @param _metadata Optional metadata that can be used to provide additional information on the dispute to be created\r\n    * @return Dispute identification number\r\n    */\r\n    function createDispute(uint256 _possibleRulings, bytes calldata _metadata) external returns (uint256) {\r\n        possibleRulings = _possibleRulings;\r\n        metadata = _metadata;\r\n        subject = msg.sender;\r\n       \r\n        return 1000;\r\n    }\r\n\r\n    /**\r\n    * @dev Close the evidence period of a dispute\r\n    * @param _disputeId Identification number of the dispute to close its evidence submitting period\r\n    */\r\n    function submitEvidence(uint256 _disputeId, address /*subtmitter*/, bytes calldata /*proof*/) external {\r\n        evidencePeriodClosed = _disputeId;\r\n    }\r\n\r\n    /**\r\n    * @dev Close the evidence period of a dispute\r\n    * @param _disputeId Identification number of the dispute to close its evidence submitting period\r\n    */\r\n    function closeEvidencePeriod(uint256 _disputeId) external {\r\n        evidencePeriodClosed = _disputeId;\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Update the final Ruling of the dispute\r\n    * @param _rule Identification number of the dispute to be executed\r\n    */\r\n    function executeRuling(uint256 /*_disputeId*/, uint256 _rule) external {\r\n        rulingExecuted = _rule;\r\n    }\r\n\r\n    /**\r\n    * @dev Tell the dispute fees information to create a dispute\r\n    * @return recipient Address where the corresponding dispute fees must be transferred to\r\n    * @return feeToken ERC20 token used for the fees\r\n    * @return feeAmount Total amount of fees that must be allowed to the recipient\r\n    */\r\n    function getDisputeFees() external view returns (address recipient, ERC20 feeToken, uint256 feeAmount) {\r\n        return (address(this), token, 1000);\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Tell the subscription fees information for a subscriber to be up-to-date\r\n    * @return recipient Address where the corresponding subscriptions fees must be transferred to\r\n    * @return feeToken ERC20 token used for the subscription fees\r\n    * @return feeAmount Total amount of fees that must be allowed to the recipient\r\n    */\r\n    function getSubscriptionFees(address /*_subscriber*/) external view returns (address recipient, ERC20 feeToken, uint256 feeAmount) {\r\n        return (address(this), token, 1000);\r\n    }\r\n    \r\n    /**\r\n    * @dev Tell the winning outcome of the final ruling.\r\n    * @return subject address who made the dispute\r\n    * @return rulingExecuted final outcome\r\n    */\r\n    function rule(uint256 /*_disputeId*/) external view virtual returns(address, uint256){\r\n        return (subject, rulingExecuted);\r\n    }\r\n\r\n}\r\n"
    },
    "@aragon/govern-contract-utils/contracts/deposits/DepositLib.sol": {
      "content": "/*\r\n * SPDX-License-Identifier:    MIT\r\n */\r\n\r\npragma solidity ^0.6.8;\r\n\r\nimport \"erc3k/contracts/ERC3000Data.sol\";\r\n\r\nimport \"../erc20/ERC20.sol\";\r\nimport \"../erc20/SafeERC20.sol\";\r\n\r\nlibrary DepositLib {\r\n    using SafeERC20 for ERC20;\r\n\r\n    event Locked(address indexed token, address indexed from, uint256 amount);\r\n    event Unlocked(address indexed token, address indexed to, uint256 amount);\r\n\r\n    function collectFrom(ERC3000Data.Collateral memory _collateral, address _from) internal {\r\n        if (_collateral.amount > 0) {\r\n            ERC20 token = ERC20(_collateral.token);\r\n            require(token.safeTransferFrom(_from, address(this), _collateral.amount), \"deposit: bad token lock\");\r\n\r\n            emit Locked(_collateral.token, _from, _collateral.amount);\r\n        }\r\n    }\r\n\r\n    function releaseTo(ERC3000Data.Collateral memory _collateral, address _to) internal {\r\n        if (_collateral.amount > 0) {\r\n            ERC20 token = ERC20(_collateral.token);\r\n            require(token.safeTransfer(_to, _collateral.amount), \"deposit: bad token release\");\r\n\r\n            emit Unlocked(_collateral.token, _to, _collateral.amount);\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/protocol/IArbitrator.sol": {
      "content": "/*\r\n * SPDX-License-Identifier:    MIT\r\n */\r\n\r\n// From https://github.com/aragon/protocol/blob/f1b3361a160da92b9bb449c0a05dee0c30e41594/packages/evm/contracts/arbitration/IArbitrator.sol\r\n\r\npragma solidity ^0.6.8;\r\n\r\nimport \"@aragon/govern-contract-utils/contracts/erc20/ERC20.sol\";\r\n\r\ninterface IArbitrator {\r\n    /**\r\n    * @dev Create a dispute over the Arbitrable sender with a number of possible rulings\r\n    * @param _possibleRulings Number of possible rulings allowed for the dispute\r\n    * @param _metadata Optional metadata that can be used to provide additional information on the dispute to be created\r\n    * @return Dispute identification number\r\n    */\r\n    function createDispute(uint256 _possibleRulings, bytes calldata _metadata) external returns (uint256);\r\n\r\n    /**\r\n    * @dev Submit evidence for a dispute\r\n    * @param _disputeId Id of the dispute in the Protocol\r\n    * @param _submitter Address of the account submitting the evidence\r\n    * @param _evidence Data submitted for the evidence related to the dispute\r\n    */\r\n    function submitEvidence(uint256 _disputeId, address _submitter, bytes calldata _evidence) external;\r\n\r\n    /**\r\n    * @dev Close the evidence period of a dispute\r\n    * @param _disputeId Identification number of the dispute to close its evidence submitting period\r\n    */\r\n    function closeEvidencePeriod(uint256 _disputeId) external;\r\n\r\n    /**\r\n    * @notice Rule dispute #`_disputeId` if ready\r\n    * @param _disputeId Identification number of the dispute to be ruled\r\n    * @return subject Subject associated to the dispute\r\n    * @return ruling Ruling number computed for the given dispute\r\n    */\r\n    function rule(uint256 _disputeId) external returns (address subject, uint256 ruling);\r\n\r\n    /**\r\n    * @dev Tell the dispute fees information to create a dispute\r\n    * @return recipient Address where the corresponding dispute fees must be transferred to\r\n    * @return feeToken ERC20 token used for the fees\r\n    * @return feeAmount Total amount of fees that must be allowed to the recipient\r\n    */\r\n    function getDisputeFees() external view returns (address recipient, ERC20 feeToken, uint256 feeAmount);\r\n\r\n    /**\r\n    * @dev Tell the payments recipient address\r\n    * @return Address of the payments recipient module\r\n    */\r\n    function getPaymentsRecipient() external view returns (address);\r\n}\r\n"
    },
    "contracts/protocol/IArbitrable.sol": {
      "content": "/*\r\n * SPDX-License-Identifier:    MIT\r\n */\r\n\r\n// From https://github.com/aragon/protocol/blob/f1b3361a160da92b9bb449c0a05dee0c30e41594/packages/evm/contracts/arbitration/IArbitrable.sol\r\n\r\npragma solidity ^0.6.8;\r\n\r\nimport \"./IArbitrator.sol\";\r\n\r\n/**\r\n* @dev The Arbitrable instances actually don't require to follow any specific interface.\r\n*      Note that this is actually optional, although it does allow the Protocol to at least have a way to identify a specific set of instances.\r\n*/\r\nabstract contract IArbitrable {\r\n    /**\r\n    * @dev Emitted when an IArbitrable instance's dispute is ruled by an IArbitrator\r\n    * @param arbitrator IArbitrator instance ruling the dispute\r\n    * @param disputeId Identification number of the dispute being ruled by the arbitrator\r\n    * @param ruling Ruling given by the arbitrator\r\n    */\r\n    event Ruled(IArbitrator indexed arbitrator, uint256 indexed disputeId, uint256 ruling);\r\n}\r\n"
    },
    "contracts/pipelines/GovernQueue.sol": {
      "content": "/*\r\n * SPDX-License-Identifier:    GPL-3.0\r\n */\r\n\r\npragma solidity 0.6.8;\r\npragma experimental ABIEncoderV2; // required for passing structs in calldata (fairly secure at this point)\r\n\r\nimport 'erc3k/contracts/IERC3000.sol';\r\n\r\nimport '@aragon/govern-contract-utils/contracts/acl/ACL.sol';\r\nimport '@aragon/govern-contract-utils/contracts/adaptive-erc165/AdaptiveERC165.sol';\r\nimport '@aragon/govern-contract-utils/contracts/deposits/DepositLib.sol';\r\nimport '@aragon/govern-contract-utils/contracts/erc20/SafeERC20.sol';\r\nimport '@aragon/govern-contract-utils/contracts/safe-math/SafeMath.sol';\r\n\r\nimport '../protocol/IArbitrable.sol';\r\nimport '../protocol/IArbitrator.sol';\r\nimport '../protocol/IExecutable.sol';\r\n\r\nlibrary GovernQueueStateLib {\r\n    enum State {\r\n        None,\r\n        Scheduled,\r\n        Challenged,\r\n        Approved,\r\n        Rejected,\r\n        Cancelled,\r\n        Executed\r\n    }\r\n\r\n    struct Item {\r\n        State state;\r\n    }\r\n\r\n    function checkState(Item storage _item, State _requiredState)\r\n        internal\r\n        view\r\n    {\r\n        require(_item.state == _requiredState, 'queue: bad state');\r\n    }\r\n\r\n    function setState(Item storage _item, State _state) internal {\r\n        _item.state = _state;\r\n    }\r\n\r\n    function checkAndSetState(\r\n        Item storage _item,\r\n        State _fromState,\r\n        State _toState\r\n    ) internal {\r\n        checkState(_item, _fromState);\r\n        setState(_item, _toState);\r\n    }\r\n}\r\n\r\ncontract GovernQueue is IERC3000, IArbitrable, AdaptiveERC165, ACL {\r\n    // Syntax sugar to enable method-calling syntax on types\r\n    using ERC3000Data for *;\r\n    using DepositLib for ERC3000Data.Collateral;\r\n    using GovernQueueStateLib for GovernQueueStateLib.Item;\r\n    using SafeERC20 for ERC20;\r\n    using SafeMath for uint256;\r\n\r\n    // Map '4' as the 'allow' ruling; this implicitly maps '3' as the 'reject' ruling\r\n    uint256 internal constant ALLOW_RULING = 4;\r\n\r\n    // Permanent state\r\n    bytes32 public configHash; // keccak256 hash of the current ERC3000Data.Config\r\n    uint256 public nonce; // number of scheduled payloads so far\r\n    mapping(bytes32 => GovernQueueStateLib.Item) public queue; // container hash -> execution state\r\n\r\n    // Temporary state\r\n    mapping(bytes32 => address) public challengerCache; // container hash -> challenger addr (used after challenging and before dispute resolution)\r\n    mapping(bytes32 => mapping(IArbitrator => uint256)) public disputeItemCache; // container hash -> arbitrator addr -> dispute id (used between dispute creation and ruling)\r\n\r\n    /**\r\n     * @param _aclRoot account that will be given root permissions on ACL (commonly given to factory)\r\n     * @param _initialConfig initial configuration parameters\r\n     */\r\n    constructor(address _aclRoot, ERC3000Data.Config memory _initialConfig)\r\n        public\r\n        ACL(_aclRoot) // note that this contract directly derives from ACL (ACL is local to contract and not global to system in Govern)\r\n    {\r\n        initialize(_aclRoot, _initialConfig);\r\n    }\r\n\r\n    function initialize(\r\n        address _aclRoot,\r\n        ERC3000Data.Config memory _initialConfig\r\n    ) public initACL(_aclRoot) onlyInit('queue') {\r\n        _setConfig(_initialConfig);\r\n        _registerStandard(type(IERC3000).interfaceId);\r\n    }\r\n\r\n    /**\r\n     * @notice Schedules an action for execution, allowing for challenges and vetos on a defined time window. Pulls collateral from submitter into contract.\r\n     * @param _container A ERC3000Data.Container struct holding both the payload being scheduled for execution and\r\n     * the current configuration of the system\r\n     */\r\n    function schedule(\r\n        ERC3000Data.Container memory _container // TO FIX: Container is in memory and function has to be public to avoid an unestrutable solidity crash\r\n    )\r\n        public\r\n        override\r\n        auth(this.schedule.selector) // note that all functions in this contract are ACL protected (commonly some of them will be open for any addr to perform)\r\n        returns (bytes32 containerHash)\r\n    {\r\n        // prevent griefing by front-running (the same container is sent by two different people and one must be challenged)\r\n        // and ensure container hashes are unique\r\n        require(_container.payload.nonce == ++nonce, 'queue: bad nonce');\r\n        // hash using ERC3000Data.hash(ERC3000Data.Config)\r\n        bytes32 _configHash = _container.config.hash();\r\n        // ensure that the hash of the config passed in the container matches the current config (implicit agreement approval by scheduler)\r\n        require(_configHash == configHash, 'queue: bad config');\r\n        // ensure that the time delta to the execution timestamp provided in the payload is at least after the config's execution delay\r\n        require(\r\n            _container.payload.executionTime >=\r\n                _container.config.executionDelay.add(block.timestamp),\r\n            'queue: bad delay'\r\n        );\r\n        // ensure that the submitter of the payload is also the sender of this call\r\n        require(\r\n            _container.payload.submitter == msg.sender,\r\n            'queue: bad submitter'\r\n        );\r\n        // Restrict the size of calldata to _container.config.maxCalldataSize to make sure challenge function stays callable\r\n        uint256 calldataSize;\r\n        assembly {\r\n            calldataSize := calldatasize()\r\n        }\r\n        require(\r\n            calldataSize <= _container.config.maxCalldataSize,\r\n            'calldatasize: limit exceeded'\r\n        );\r\n\r\n        for (\r\n            uint256 index = 0;\r\n            index < _container.payload.actions.length;\r\n            index++\r\n        ) {\r\n            IExecutable executable = IExecutable(\r\n                _container.payload.actions[index].to\r\n            ); // Contract that can execute the action\r\n            require(\r\n                executable.canExecute(msg.sender),\r\n                'Action can''t be executed'\r\n            );\r\n        }\r\n\r\n        // store and set container's hash\r\n        containerHash = ERC3000Data.containerHash(\r\n            _container.payload.hash(),\r\n            _configHash\r\n        );\r\n        queue[containerHash].checkAndSetState(\r\n            GovernQueueStateLib.State.None, // ensure that the state for this container is None\r\n            GovernQueueStateLib.State.Scheduled // and if so perform a state transition to Scheduled\r\n        );\r\n        // we don't need to save any more state about the container in storage\r\n        // we just authenticate the hash and assign it a state, since all future\r\n        // actions regarding the container will need to provide it as a witness\r\n        // all witnesses are logged from this contract at least once, so the\r\n        // trust assumption should be the same as storing all on-chain (move complexity to clients)\r\n\r\n        ERC3000Data.Collateral memory collateral = _container\r\n            .config\r\n            .scheduleDeposit;\r\n        collateral.collectFrom(_container.payload.submitter); // pull collateral from submitter (requires previous approval)\r\n\r\n        // the configured resolver may specify additional out-of-band payments for scheduling actions\r\n        // schedule() leaves these requirements up to the callers of `schedule()` or other users to fulfill\r\n\r\n        // emit an event to ensure data availability of all state that cannot be otherwise fetched (see how config isn't emitted since an observer should already have it)\r\n        emit Scheduled(containerHash, _container.payload);\r\n    }\r\n\r\n    /**\r\n     * @notice Executes an action after its execution delay has passed and its state hasn't been altered by a challenge or veto\r\n     * @param _container A ERC3000Data.Container struct holding both the payload being scheduled for execution and\r\n     * the current configuration of the system\r\n     */\r\n    function execute(ERC3000Data.Container memory _container)\r\n        public\r\n        override\r\n        auth(this.execute.selector) // in most instances this will be open for any addr, but leaving configurable for flexibility\r\n        returns (bytes32 failureMap, bytes[] memory)\r\n    {\r\n        // ensure enough time has passed\r\n        require(\r\n            block.timestamp >= _container.payload.executionTime,\r\n            'queue: wait more'\r\n        );\r\n\r\n        bytes32 containerHash = _container.hash();\r\n        queue[containerHash].checkAndSetState(\r\n            GovernQueueStateLib.State.Scheduled, // note that we will revert here if the container wasn't previously scheduled\r\n            GovernQueueStateLib.State.Executed\r\n        );\r\n\r\n        _container.config.scheduleDeposit.releaseTo(\r\n            _container.payload.submitter\r\n        ); // release collateral to original submitter\r\n\r\n        return _execute(_container.payload, containerHash);\r\n    }\r\n\r\n    /**\r\n     * @notice Challenge a container in case its scheduling is illegal as per Config.rules. Pulls collateral and dispute fees from sender into contract\r\n     * @param _container A ERC3000Data.Container struct holding both the payload being scheduled for execution and\r\n     * the current configuration of the system\r\n     * @param _reason Hint for case reviewers as to why the scheduled container is illegal\r\n     */\r\n    function challenge(\r\n        ERC3000Data.Container memory _container,\r\n        bytes memory _reason\r\n    )\r\n        public\r\n        override\r\n        auth(this.challenge.selector)\r\n        returns (uint256 disputeId)\r\n    {\r\n        bytes32 containerHash = _container.hash();\r\n        challengerCache[containerHash] = msg.sender; // cache challenger address while it is needed\r\n        queue[containerHash].checkAndSetState(\r\n            GovernQueueStateLib.State.Scheduled,\r\n            GovernQueueStateLib.State.Challenged\r\n        );\r\n\r\n        ERC3000Data.Collateral memory collateral = _container\r\n            .config\r\n            .challengeDeposit;\r\n        collateral.collectFrom(msg.sender); // pull challenge collateral from sender\r\n\r\n        // create dispute on arbitrator\r\n        IArbitrator arbitrator = IArbitrator(_container.config.resolver);\r\n        (address recipient, ERC20 feeToken, uint256 feeAmount) = arbitrator\r\n            .getDisputeFees();\r\n        require(\r\n            feeToken.safeTransferFrom(msg.sender, address(this), feeAmount),\r\n            'queue: bad fee pull'\r\n        );\r\n        require(\r\n            feeToken.safeApprove(recipient, feeAmount),\r\n            'queue: bad approve'\r\n        );\r\n        _container.payload.challenger = msg.sender;\r\n        disputeId = arbitrator.createDispute(2, abi.encode(_container)); // create dispute sending full container ABI encoded (could prob just send payload to save gas)\r\n        require(feeToken.safeApprove(recipient, 0), 'queue: bad reset'); // reset just in case non-compliant tokens (that fail on non-zero to non-zero approvals) are used\r\n\r\n        // submit both arguments as evidence and close evidence period. no more evidence can be submitted and a settlement can't happen (could happen off-protocol)\r\n        arbitrator.submitEvidence(\r\n            disputeId,\r\n            _container.payload.submitter,\r\n            _container.payload.proof\r\n        );\r\n        arbitrator.submitEvidence(disputeId, msg.sender, _reason);\r\n        arbitrator.closeEvidencePeriod(disputeId);\r\n\r\n        disputeItemCache[containerHash][arbitrator] = disputeId + 1; // cache a relation between disputeId and containerHash while needed\r\n\r\n        emit Challenged(\r\n            containerHash,\r\n            msg.sender,\r\n            _reason,\r\n            disputeId,\r\n            collateral\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Apply arbitrator's ruling over a challenge once it has come to a final ruling\r\n     * @param _container A ERC3000Data.Container struct holding both the payload being scheduled for execution and\r\n     * the current configuration of the system\r\n     * @param _disputeId disputeId in the arbitrator in which the dispute over the container was created\r\n     */\r\n    function resolve(\r\n        ERC3000Data.Container memory _container,\r\n        uint256 _disputeId\r\n    ) public override returns (bytes32 failureMap, bytes[] memory) {\r\n        bytes32 containerHash = _container.hash();\r\n        IArbitrator arbitrator = IArbitrator(_container.config.resolver);\r\n\r\n        require(\r\n            disputeItemCache[containerHash][arbitrator] == _disputeId + 1,\r\n            'queue: bad dispute id'\r\n        );\r\n        delete disputeItemCache[containerHash][arbitrator]; // release state to refund gas; no longer needed in state\r\n\r\n        queue[containerHash].checkState(GovernQueueStateLib.State.Challenged);\r\n        (address subject, uint256 ruling) = arbitrator.rule(_disputeId);\r\n        require(subject == address(this), 'queue: not subject');\r\n        bool arbitratorApproved = ruling == ALLOW_RULING;\r\n\r\n        queue[containerHash].setState(\r\n            arbitratorApproved\r\n                ? GovernQueueStateLib.State.Approved\r\n                : GovernQueueStateLib.State.Rejected\r\n        );\r\n\r\n        emit Resolved(containerHash, msg.sender, arbitratorApproved);\r\n        emit Ruled(arbitrator, _disputeId, ruling);\r\n\r\n        if (arbitratorApproved) {\r\n            return _executeApproved(_container);\r\n        } else {\r\n            return _settleRejection(_container);\r\n        }\r\n    }\r\n\r\n    function veto(ERC3000Data.Container memory _container, bytes memory _reason)\r\n        public\r\n        override\r\n        auth(this.veto.selector)\r\n    {\r\n        bytes32 containerHash = _container.hash();\r\n        GovernQueueStateLib.Item storage item = queue[containerHash];\r\n\r\n        if (item.state == GovernQueueStateLib.State.Challenged) {\r\n            item.checkAndSetState(\r\n                GovernQueueStateLib.State.Challenged,\r\n                GovernQueueStateLib.State.Cancelled\r\n            );\r\n\r\n            address challenger = challengerCache[containerHash];\r\n            // release state to refund gas; no longer needed in state\r\n            delete challengerCache[containerHash];\r\n            delete disputeItemCache[containerHash][\r\n                IArbitrator(_container.config.resolver)\r\n            ];\r\n\r\n            // release collateral to challenger and scheduler\r\n            _container.config.scheduleDeposit.releaseTo(\r\n                _container.payload.submitter\r\n            );\r\n            _container.config.challengeDeposit.releaseTo(challenger);\r\n        } else {\r\n            // If the given container doesn't have the state Challenged\r\n            // has it to be the Scheduled state and otherwise should it throw as expected\r\n            item.checkAndSetState(\r\n                GovernQueueStateLib.State.Scheduled,\r\n                GovernQueueStateLib.State.Cancelled\r\n            );\r\n\r\n            _container.config.scheduleDeposit.releaseTo(\r\n                _container.payload.submitter\r\n            );\r\n        }\r\n\r\n        emit Vetoed(containerHash, msg.sender, _reason);\r\n    }\r\n\r\n    /**\r\n     * @notice Apply a new configuration for all *new* containers to be scheduled\r\n     * @param _config A ERC3000Data.Config struct holding all the new params that will control the queue\r\n     */\r\n    function configure(ERC3000Data.Config memory _config)\r\n        public\r\n        override\r\n        auth(this.configure.selector)\r\n        returns (bytes32)\r\n    {\r\n        return _setConfig(_config);\r\n    }\r\n\r\n    // Internal\r\n\r\n    function _executeApproved(ERC3000Data.Container memory _container)\r\n        internal\r\n        returns (bytes32 failureMap, bytes[] memory)\r\n    {\r\n        bytes32 containerHash = _container.hash();\r\n        queue[containerHash].checkAndSetState(\r\n            GovernQueueStateLib.State.Approved,\r\n            GovernQueueStateLib.State.Executed\r\n        );\r\n\r\n        delete challengerCache[containerHash]; // release state to refund gas; no longer needed in state\r\n\r\n        // release all collateral to submitter\r\n        _container.config.scheduleDeposit.releaseTo(\r\n            _container.payload.submitter\r\n        );\r\n        _container.config.challengeDeposit.releaseTo(\r\n            _container.payload.submitter\r\n        );\r\n\r\n        return _execute(_container.payload, containerHash);\r\n    }\r\n\r\n    function _settleRejection(ERC3000Data.Container memory _container)\r\n        internal\r\n        returns (bytes32, bytes[] memory)\r\n    {\r\n        bytes32 containerHash = _container.hash();\r\n        queue[containerHash].checkAndSetState(\r\n            GovernQueueStateLib.State.Rejected,\r\n            GovernQueueStateLib.State.Cancelled\r\n        );\r\n\r\n        address challenger = challengerCache[containerHash];\r\n        delete challengerCache[containerHash]; // release state to refund gas; no longer needed in state\r\n\r\n        // release all collateral to challenger\r\n        _container.config.scheduleDeposit.releaseTo(challenger);\r\n        _container.config.challengeDeposit.releaseTo(challenger);\r\n\r\n        // return zero values as nothing is executed on rejection\r\n    }\r\n\r\n    function _execute(\r\n        ERC3000Data.Payload memory _payload,\r\n        bytes32 _containerHash\r\n    ) internal returns (bytes32, bytes[] memory) {\r\n        emit Executed(_containerHash, msg.sender);\r\n        return\r\n            _payload.executor.exec(\r\n                _payload.actions,\r\n                _payload.allowFailuresMap,\r\n                _containerHash\r\n            );\r\n    }\r\n\r\n    function _setConfig(ERC3000Data.Config memory _config)\r\n        internal\r\n        returns (bytes32)\r\n    {\r\n        // validate collaterals by calling balanceOf on their interface\r\n        if (\r\n            _config.challengeDeposit.amount != 0 &&\r\n            _config.challengeDeposit.token != address(0)\r\n        ) {\r\n            (bool ok, bytes memory value) = _config.challengeDeposit.token.call(\r\n                abi.encodeWithSelector(ERC20.balanceOf.selector, address(this))\r\n            );\r\n            require(ok && value.length > 0, 'queue: bad config');\r\n        }\r\n\r\n        if (\r\n            _config.scheduleDeposit.amount != 0 &&\r\n            _config.scheduleDeposit.token != address(0)\r\n        ) {\r\n            (bool ok, bytes memory value) = _config.scheduleDeposit.token.call(\r\n                abi.encodeWithSelector(ERC20.balanceOf.selector, address(this))\r\n            );\r\n            require(ok && value.length > 0, 'queue: bad config');\r\n        }\r\n\r\n        configHash = _config.hash();\r\n\r\n        emit Configured(configHash, msg.sender, _config);\r\n\r\n        return configHash;\r\n    }\r\n}\r\n"
    },
    "@aragon/govern-contract-utils/contracts/safe-math/SafeMath.sol": {
      "content": "/*\r\n * SPDX-License-Identifier:    GPL-3.0\r\n */\r\n\r\npragma solidity ^0.6.8;\r\n\r\n// A library for performing overflow-safe math, courtesy of DappHub: https://github.com/dapphub/ds-math/blob/d0ef6d6a5f/src/math.sol\r\n// Modified to include only the essentials\r\nlibrary SafeMath {\r\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require((z = x + y) >= x, \"math: overflow\");\r\n    }\r\n\r\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require((z = x - y) <= x, \"math: underflow\");\r\n    }\r\n}\r\n"
    },
    "contracts/protocol/IExecutable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.6.8;\r\n\r\ninterface IExecutable {\r\n    function canExecute(address executer) external returns (bool);\r\n}\r\n"
    },
    "contracts/test/TestToken.sol": {
      "content": "/*\r\n * SPDX-License-Identifier:    GPL-3.0\r\n */\r\n\r\npragma solidity ^0.6.8;\r\n\r\nimport \"@aragon/govern-contract-utils/contracts/initializable/Initializable.sol\";\r\n\r\nimport '@aragon/govern-token/contracts/interfaces/IERC20.sol';\r\nimport '@aragon/govern-contract-utils/contracts/safe-math/SafeMath.sol';\r\n\r\ncontract TestToken is IERC20, Initializable {\r\n    using SafeMath for uint256;\r\n    bytes32 private constant EIP712DOMAIN_HASH = 0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\r\n    bytes32 private constant VERSION_HASH = 0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6;\r\n    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\r\n    bytes32 public constant TRANSFER_WITH_AUTHORIZATION_TYPEHASH = 0x7c7c6cdb67a18743f49ec6fa9b35f50d52ed05cbed4cc592e13b44501c1a2267;\r\n\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals;\r\n\r\n    address public minter;\r\n    uint256 override public totalSupply;\r\n    mapping (address => uint256) override public balanceOf;\r\n    mapping (address => mapping (address => uint256)) override public allowance;\r\n\r\n    // ERC-2612, ERC-3009 state\r\n    mapping (address => uint256) public nonces;\r\n    mapping (address => mapping (bytes32 => bool)) public authorizationState;\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event AuthorizationUsed(address indexed authorizer, bytes32 indexed nonce);\r\n    event ChangeMinter(address indexed minter);\r\n\r\n    modifier onlyMinter {\r\n        require(msg.sender == minter, \"token: not minter\");\r\n        _;\r\n    }\r\n\r\n    constructor(address _initialMinter) public {\r\n        initialize(_initialMinter, 'TestToken', 'TT', 64);\r\n    }\r\n\r\n    function initialize(address _initialMinter, string memory _name, string memory _symbol, uint8 _decimals) public onlyInit(\"token\") {\r\n        _changeMinter(_initialMinter);\r\n        name = _name;\r\n        symbol = _symbol;\r\n        decimals = _decimals;\r\n    }\r\n\r\n    function _validateSignedData(address signer, bytes32 encodeData, uint8 v, bytes32 r, bytes32 s) internal view {\r\n        bytes32 digest = keccak256(\r\n            abi.encodePacked(\r\n                \"\\x19\\x01\",\r\n                getDomainSeparator(),\r\n                encodeData\r\n            )\r\n        );\r\n        address recoveredAddress = ecrecover(digest, v, r, s);\r\n        require(recoveredAddress != address(0) && recoveredAddress == signer, \"token: bad sig\");\r\n    }\r\n\r\n    function _changeMinter(address newMinter) internal {\r\n        minter = newMinter;\r\n        emit ChangeMinter(newMinter);\r\n    }\r\n\r\n    function _mint(address to, uint256 value) internal {\r\n        totalSupply = totalSupply.add(value);\r\n        balanceOf[to] = balanceOf[to].add(value);\r\n        emit Transfer(address(0), to, value);\r\n    }\r\n\r\n    function _burn(address from, uint value) internal {\r\n        // Balance is implicitly checked with SafeMath's underflow protection\r\n        balanceOf[from] = balanceOf[from].sub(value);\r\n        totalSupply = totalSupply.sub(value);\r\n        emit Transfer(from, address(0), value);\r\n    }\r\n\r\n    function _approve(address owner, address spender, uint256 value) private {\r\n        allowance[owner][spender] = value;\r\n        emit Approval(owner, spender, value);\r\n    }\r\n\r\n    function _transfer(address from, address to, uint256 value) private {\r\n        require(to != address(this) && to != address(0), \"token: bad to\");\r\n\r\n        balanceOf[from] = balanceOf[from].sub(value);\r\n        balanceOf[to] = balanceOf[to].add(value);\r\n        emit Transfer(from, to, value);\r\n    }\r\n\r\n    function getChainId() public pure returns (uint256 chainId) {\r\n        assembly { chainId := chainid() }\r\n    }\r\n\r\n    function getDomainSeparator() public view returns (bytes32) {\r\n        return keccak256(\r\n            abi.encode(\r\n                EIP712DOMAIN_HASH,\r\n                keccak256(abi.encodePacked(name)),\r\n                VERSION_HASH,\r\n                getChainId(),\r\n                address(this)\r\n            )\r\n        );\r\n    }\r\n\r\n    function mint(address to, uint256 value) external onlyMinter returns (bool) {\r\n        _mint(to, value);\r\n        return true;\r\n    }\r\n\r\n    function changeMinter(address newMinter) external onlyMinter {\r\n        _changeMinter(newMinter);\r\n    }\r\n\r\n    function burn(uint256 value) external returns (bool) {\r\n        _burn(msg.sender, value);\r\n        return true;\r\n    }\r\n\r\n    function approve(address spender, uint256 value) override external returns (bool) {\r\n        _approve(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    function transfer(address to, uint256 value) override external returns (bool) {\r\n        _transfer(msg.sender, to, value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint256 value) override external returns (bool) {\r\n        uint256 fromAllowance = allowance[from][msg.sender];\r\n        if (fromAllowance != uint256(-1)) {\r\n        allowance[from][msg.sender] = fromAllowance.sub(value);\r\n        }\r\n        _transfer(from, to, value);\r\n        return true;\r\n    }\r\n\r\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external {\r\n        require(deadline >= block.timestamp, \"token: auth expired\");\r\n\r\n        bytes32 encodeData = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline));\r\n        _validateSignedData(owner, encodeData, v, r, s);\r\n\r\n        _approve(owner, spender, value);\r\n    }\r\n\r\n    function transferWithAuthorization(\r\n    address from,\r\n    address to,\r\n    uint256 value,\r\n    uint256 validAfter,\r\n    uint256 validBefore,\r\n    bytes32 nonce,\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s\r\n    )\r\n    external\r\n    {\r\n        require(block.timestamp > validAfter, \"token: auth wait\");\r\n        require(block.timestamp < validBefore, \"token: auth expired\");\r\n        require(!authorizationState[from][nonce],  \"token: auth used\");\r\n\r\n        bytes32 encodeData = keccak256(abi.encode(TRANSFER_WITH_AUTHORIZATION_TYPEHASH, from, to, value, validAfter, validBefore, nonce));\r\n        _validateSignedData(from, encodeData, v, r, s);\r\n\r\n        authorizationState[from][nonce] = true;\r\n        emit AuthorizationUsed(from, nonce);\r\n\r\n        _transfer(from, to, value);\r\n    }\r\n}\r\n"
    },
    "@aragon/govern-token/contracts/interfaces/IERC20.sol": {
      "content": "/*\r\n * SPDX-License-Identifier:    GPL-3.0\r\n */\r\n\r\npragma solidity ^0.6.8;\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n}\r\n"
    },
    "erc3k/contracts/IERC3000Registry.sol": {
      "content": "/*\r\n * SPDX-License-Identifier:    MIT\r\n */\r\n\r\npragma solidity 0.6.8;\r\n\r\nimport \"./IERC3000.sol\";\r\nimport \"./IERC3000Executor.sol\";\r\n\r\nimport \"@aragon/govern-token/contracts/interfaces/IERC20.sol\";\r\n\r\nabstract contract IERC3000Registry {\r\n    /**\r\n     * @notice Registers a IERC3000Executor and IERC3000 contract by a name and with his metadata\r\n     * @param executor IERC3000Executor contract\r\n     * @param queue IERC3000 contract\r\n     * @param name The name of this DAO\r\n     * @param token Governance token of the DAO\r\n     * @param initialMetadata Additional data to store for this DAO\r\n     */\r\n    function register(IERC3000Executor executor, IERC3000 queue, IERC20 token, address minter, string calldata name, bytes calldata initialMetadata) virtual external;\r\n    event Registered(IERC3000Executor indexed executor, IERC3000 queue, IERC20 indexed token, address minter, address indexed registrant, string name);\r\n\r\n    /**\r\n     * @notice Sets or updates the metadata of a DAO\r\n     * @param metadata Additional data to store for this DAO\r\n     */\r\n    function setMetadata(bytes memory metadata) virtual public;\r\n    event SetMetadata(IERC3000Executor indexed executor, bytes metadata);\r\n}\r\n"
    },
    "contracts/test/ERC3000ExecutorMock.sol": {
      "content": "/*\r\n * SPDX-License-Identifier:    MIT\r\n */\r\n\r\npragma solidity ^0.6.8;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"erc3k/contracts/IERC3000Executor.sol\";\r\n\r\nimport \"@aragon/govern-contract-utils/contracts/erc165/ERC165.sol\";\r\nimport \"@aragon/govern-contract-utils/contracts/erc165/ERC165.sol\";\r\n\r\ncontract ERC3000ExecutorMock is IERC3000Executor, ERC165 {\r\n    uint256 public passedActionsLength;\r\n    bytes32 public passedAllowFailuresMap;\r\n    bytes32 public passedContainerHash;\r\n\r\n    function exec(ERC3000Data.Action[] memory actions, bytes32 allowFailuresMap, bytes32 containerHash) override public returns (bytes32, bytes[] memory) {\r\n        passedActionsLength = actions.length;\r\n        passedAllowFailuresMap = allowFailuresMap;\r\n        passedContainerHash = containerHash;\r\n\r\n        return (bytes32(0), new bytes[](actions.length));\r\n    }\r\n\r\n    function interfaceID() public pure returns (bytes4) {\r\n        return ERC3000_EXEC_INTERFACE_ID;\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceId) override public view returns (bool) {\r\n        return interfaceId == ERC3000_EXEC_INTERFACE_ID;\r\n    }\r\n}\r\n"
    },
    "contracts/test/ERC3000Mock.sol": {
      "content": "/*\r\n * SPDX-License-Identifier:    MIT\r\n */\r\n\r\npragma solidity ^0.6.8;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"erc3k/contracts/IERC3000.sol\";\r\n\r\nimport \"@aragon/govern-contract-utils/contracts/erc165/ERC165.sol\";\r\n\r\ncontract ERC3000Mock is IERC3000, ERC165 {\r\n    function schedule(ERC3000Data.Container memory) override public returns (bytes32) { }\r\n\r\n    function execute(ERC3000Data.Container memory) override public returns (bytes32, bytes[] memory) { }\r\n\r\n    function challenge(ERC3000Data.Container memory, bytes memory) override public returns (uint256 resolverId) { }\r\n\r\n    function resolve(ERC3000Data.Container memory, uint256) override public returns (bytes32, bytes[] memory) { }\r\n\r\n    function veto(ERC3000Data.Container memory, bytes memory) override public { }\r\n\r\n    function configure(ERC3000Data.Config memory) override public returns (bytes32) { }\r\n\r\n    function interfaceID() public pure returns (bytes4) {\r\n        return type(IERC3000).interfaceId;\r\n    }\r\n}\r\n"
    },
    "contracts/GovernRegistry.sol": {
      "content": "/*\r\n * SPDX-License-Identifier:    GPL-3.0\r\n */\r\n\r\npragma solidity 0.6.8;\r\n\r\nimport \"erc3k/contracts/IERC3000.sol\";\r\nimport \"erc3k/contracts/IERC3000Executor.sol\";\r\nimport \"erc3k/contracts/IERC3000Registry.sol\";\r\n\r\nimport \"@aragon/govern-contract-utils/contracts/erc165/ERC165.sol\";\r\n\r\ncontract GovernRegistry is IERC3000Registry {\r\n    mapping(string => bool) public nameUsed;\r\n\r\n    function register(\r\n        IERC3000Executor _executor,\r\n        IERC3000 _queue,\r\n        IERC20 _token,\r\n        address minter,\r\n        string calldata _name,\r\n        bytes calldata _initialMetadata\r\n    ) override external\r\n    {\r\n        require(!nameUsed[_name], \"registry: name used\");\r\n\r\n        nameUsed[_name] = true;\r\n\r\n        emit Registered(_executor, _queue, _token, minter, msg.sender, _name);\r\n        _setMetadata(_executor, _initialMetadata);\r\n    }\r\n\r\n    function setMetadata(bytes memory _metadata) override public {\r\n        _setMetadata(IERC3000Executor(msg.sender), _metadata);\r\n    }\r\n\r\n    function _setMetadata(IERC3000Executor _executor, bytes memory _metadata) internal {\r\n        emit SetMetadata(_executor, _metadata);\r\n    }\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 2000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}